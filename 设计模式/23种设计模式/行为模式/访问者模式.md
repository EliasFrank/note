![1597795499582](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1597795499582.png)

1. 如果系统比较小，还是OK的，但是考虑系统增加越来越多新的功能时，对代码改动较大，违反了OCP原则
2. 扩展性不好，比如增加了新的人员类型，或者管理方法，都不好做

---

**基本介绍**

1. 访问者模式（visitor pattern），封装一些作用于某种数据结构的各元素的操作，他可以在不改变数据结构的前提下定义作用域这些元素的新的操作
2. 主要将数据结构与数据操作分离，解决数据结构和操作耦合性的问题
3. 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口
4. 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作（这些操作彼此没有关联），同时需要避免让这些操作'污染'这些对象的类，可以选用访问者模式解决

---

![1597796251833](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1597796251833.png)

1. visitor是抽象访问者，为该对象结构中的ConcreateElement的每一个类声明一个visit操作
2. concreateVisitor是一个具体的访问值，实现每个有visitor声明的操作
3. ObjectStructure能枚举他的元素，可以提供一个高层的接口，用来允许访问者访问元素
4. Element定义一个accept方法，接收一个访问者对象
5. concreateElement为具体元素，实现了accept方法

这里我们使用到了双分派，即首先在客户端程序中，将具体状态作为参数传递woman（第一次分派）。让后woman类调用作为参数的“具体方法”中方法getWomanResult，同时将自己（this）作为参数传入，完成第二次分派。

双分派是指不管类怎么变化，我们都能找到期望的方法运行。双分派意味着得到执行的操作取决于请求的种类和两个接受者的类型

---

**注意事项和细节**

优点：

1. 访问者模式符合单一职责原则，让程序具有优秀的扩展性、灵活性非常高
2. 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统

缺点

1. 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难
2. 违背了依赖倒转原则，访问者依赖的时具体元素，而不是抽象元素
3. 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，你们访问者模式就是比较合适的

----

另一个例子：

​    现在有一个学校，学校里只有学生和老师两个群体，是相对稳定的。第一天校长让你把所有学生和老师的名字都找出来，你写了一份得到所有人员的名字的代码；第二天校长让你把所有学生和老师的年龄都找出来，你又写了一份得到所有人员年龄的代码；第三天校长让你通过学生老师的入学时间来计算工龄和学龄，你还要再写一份代码来计算

![img](https://img-blog.csdnimg.cn/20200630092408400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyMjEzMQ==,size_16,color_FFFFFF,t_70)

  对于访问者，抽象出来一个接口IVisitor，里面定义了visit方法，visit方法是实现访问的关键。这里因为学校只有学生和老师所以定义了两个方法（这里就体现出了访问者模式适用于数据结构相对稳定的系统，该问题中假定了学校就只有老师和学生就非常稳定，访问者的接口不会改变，如果学校未来可能还会加入了清洁工、门卫等那么数据结构就是不稳定的，就不能使用访问者模式，因为如果增加了清洁工和门卫，访问者的接口也要改变，这就违背了开闭原则，是不好的）



















