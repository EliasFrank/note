### java内存模型

JMM定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性，有序性和原子性的规则的保障）

synchronized

<img src="H:\Notes\JVM\upload\image-20210328101445738.png" alt="image-20210328101445738" style="zoom:33%;" />



#### 原子性

#### 可见性

可以使用volatile修饰变量，volatile可以使一个变量的修改对另一个线程可见。volatile不能保证原子性，仅用在一个写线程，多个读线程的情况

synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低

#### 有序性

JDK 5以上的版本的volatile才会真正有效  

### synchronized优化

java HotSpot虚拟机中，每个对象都有对象头（包括class指针和MarkWord）。Mark Word平时存储这个对象的哈希码，分代年龄，当加锁时，这些信息就根据情况被替换为标记位、线程记录指针、重量级锁指针、线程ID等内容

#### 重量锁

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞

在java6之后，自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能

* 自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势
* 好比等红灯时骑车是不是熄火，不熄火相当于自旋（等待时间短了划算），熄火了相当于阻塞（等待时间长了划算）
* java 7之后不能控制是否开启自旋功能

#### 偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作，java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的MarkWOrd头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS

* 撤销偏向需要将持锁的线程省纪委轻量级锁，这个过程中所有线程需要暂停（STW）
* 访问对象的hashCode也会撤销偏向锁
* 如果对象虽然被多个线程访问，但没有竞争，这时偏向了1的对象仍有机会重新偏向2，重偏向会重置对象的ThreadID
* 撤销偏向和重偏向都是批量进行的，以类为单位
* 如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的
* 可以主动使用-XX:-UseBiasedLocking禁用偏向锁

#### 其他优化

减少上锁时间

减少锁的粒度

锁粗化

锁消除

读写分离