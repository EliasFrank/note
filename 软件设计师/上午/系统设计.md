### 设计原则

* 单一职责原则：设计目的单一的类
* 开放-封闭原则：对扩展开放，对修改封闭
* 里式替换原则：子类可以替换父类
* 依赖倒置原则：要依赖于抽象而不是具体实现；针对接口编程，不要针对实现编程
* 接口隔离原则：使用多个专门的接口比使用单一的总接口要好
* 组合重用原则：要尽量使用组合，而不是继承关系达到重用目的
* 迪米特法则（最少知道原则）：一个对象应当对其他对象有尽可能少的了解

### UML

![1603590184369](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603590184369.png)

### 设计模式的概念

* 架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反应了开发软件系统过程中所作的基本设计决策
* 设计模式：主要关注软件系统的设计，与具体的实现语言无关
* 惯用法：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有他自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言的一种惯用法。

### 设计模式的分类

#### 创建型模式：

* 工厂方法模式
* 抽象工厂模式
* 原型模式
* 单例模式
* 构建器模式

#### 结构型模式

* 适配器模式
* 桥接模式
* 组合模式
* 装饰模式
* 外观模式
* 享元模式
* 代理模式

#### 行为型模式

* 职责链模式
* 命令模式
* 解释器模式
* 迭代器模式
* 中介者模式
* 备忘录模式
* 观察者模式
* 状态模式
* 策略模式
* 模板方法模式
* 访问者模式

### 创建型模式

| 设计模式名称 | 简要说明                                                     |
| ------------ | ------------------------------------------------------------ |
| 抽象工厂模式 | 提供一个结构，可以创建一系列相关或相互依赖的对象，而无需指定他们具体的类 |
| 构建器模式   | 将一个复杂类的表示与其构造相分离，使得相同的构建过程能够得出不同的表示 |
| 工厂方法模式 | 定义一个创建对象的接口，但由子类决定需要实例化哪一个类。工厂方法使得子类实例化的过程推迟 |
| 原型模式     | 用原型实例指定创建对象的类型，并且通过拷贝这个原型来创建新的对象 |
| 单例模式     | 保证一个类只有一个实例，并提供一个访问他的全局访问点         |

### 结构型模式

| 设计模式名称 | 简要说明                                                     | 速记关键字   |
| ------------ | ------------------------------------------------------------ | ------------ |
| 适配器模式   | 将一个类的接口转换成用户希望得到的另一种接口。它使原本不相容的接口得以协同工作 | 转换接口     |
| 桥接模式     | 将类的抽象部分和它的实现部分分离开来，使他们可以独立的变化   | 继承树拆分   |
| 组合模式     | 将对象组合成树型结构以表示“整体-部分”的层次结构，使得用户对单个对象和组合对象的使用具有一致性 | 树型目录结构 |
| 装饰模式     | 动态的给一个对象添加一些额外的职责。他提供了用子类扩展功能的一个灵活的替代，比派生一个子类更加灵活 | 附加职责     |
| 外观模式     | 定义一个高层接口，为子系统中的一组接口提供一个一致的外观，从而简化了该子系统的使用 | 对外统一接口 |
| 享元模式     | 提供支持大量细粒度对象共享的有效方法                         |              |
| 代理模式     | 为其他对象提供一种代理以控制这个对象的访问                   |              |

### 行为型模式

| 设计模式名称 | 简要说明                                                     | 速记关键字       |
| ------------ | ------------------------------------------------------------ | ---------------- |
| 职责链       | 通过给多个对象处理请求的机会，减少请求的发送者与接收者之间的耦合。将接收对象链起来，在链中传递请求，知道有一个对象处理这个请求 | 传递职责         |
| 命令         | 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作 | 日志记录，可撤销 |
| 解释器       | 给定一一种语言，定义他的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语句中的句子 |                  |
| 迭代器       | 提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示 |                  |
| 中介者       | 用一个中介对象来封装一系列的对象交互。它使各对象不需要显示地相互调用，从而达到低耦合，还可以独立地改变对象间的交互 | 不直接引用       |
| 备忘录       | 在不破话封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，从而可以再以后将该对象回复到原先保存的状态 |                  |
| 观察者       | 定义对象间的一种一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于他的对象都得到通知并自动更新 |                  |
| 状态         | 允许一个对象在其内部状态改变时改变它的行为                   | 状态变成类       |
| 策略         | 定义一系列算法，把他们一个个封装起来，并且使他们之间可互相替换，从而让算法可以独立于使用它的用户而变化 | 多方案切换       |
| 模板方法     | 定义一个操作中的算法骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重新定义算法的某些特定步骤 |                  |
| 访问者       | 表示一个作用于某对象结构中的各元素的操作，，使得在不改变各元素的类的前提下定义作用于这些元素的新操作 |                  |

