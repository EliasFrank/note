### 数组

| 数组类型         | 存储地址计算                                                 |
| ---------------- | ------------------------------------------------------------ |
| 一维数组a[n]     | a[i]的储存地址为：a+i*len                                    |
| 二维数组a\[m][n] | a\[i][j]的存储地址（按行存储）为：a+(i\*n+j)\*len        a\[i][j]的存储地址（按列存储）为：a+(j\*m+i)\*len |

### 稀疏矩阵

![1603348518445](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603348518445.png)

### 线性表

#### 定义

1. 线性表的概念

    （a1，a2,  ..., an）

2. 线性表常见的两种存储结构

    顺序存储结构：顺序表

    链式存储结构：链表

![1603349035810](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603349035810.png)

| 性能类别 | 具体项目 | 顺序存储                       | 链式存储                             |
| -------- | -------- | ------------------------------ | ------------------------------------ |
| 空间性能 | 存储密度 | =1，更优                       | <1                                   |
|          | 容量分配 | 事先确定                       | 动态改变，更优                       |
| 空间性能 | 查找运算 | O(n/2)                         | O(n/2)                               |
|          | 读运算   | O(1), 更优                     | O([n+1]/2), 最好情况为1，最坏情况为n |
|          | 插入运算 | O(n/2)最好情况为O，最坏情况为n | O(1)，更优                           |
|          | 删除运算 | O([n-1]/2)                     | O(1), 更优                           |

#### 栈和队列

![1603350134139](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603350134139.png)

### 广义表

广义表是n个表元素组成的有限序列，是线性表的推广

通常用递归的形式进行定义，记做: LS=(a0.,a1,...,an)

注：其中LS是表名，ai是表元素，他可以是表（称作子表），也可以是数据元素（称为原子）。其中n是广义表的长度（也就是最外层包含的元素个数），n=0的广义表为空表，而递归定义的重数就是广义表的深度，直观的说，就是定义中所含括号的重数（原子的深度为0，空表的深度为1）

基本运算：取表头head（LS）和取表尾tail（LS）

若有：LS1 = (a, (b,c),(d,e))

head(LS1) = a

tail(LS1)=((b,c),(d,e))

### 树与二叉树

![1603352102042](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603352102042.png)

![1603352369415](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603352369415.png)

#### 二叉树的重要特性

1. 在二叉树的第i层上最多有2^(i-1)个节点(i >= 1)
2. 深度为k的二叉树最多有2^k - 1个结点(k >= 1)
3. 对任何一颗二叉树，如果其叶子节点数为n0，度为2的节点数为n2，则n0 = n2 + 1
4. 如果对一颗有n个结点的**完全二叉树**的节点按层序编号(从第1层到log2n+1层，每层从左到右)，则对任一节点i(1=<i<=n)
    * 如果i=1，则结点i无父节点，是二叉树的根，若i>1，则父节点是i/2
    * 如果2i>n，则结点i为叶子节点，无左子结点；否则其左子节点是2i
    * 如果2i+1>n，则结点i无右子节点，否则，其右子结点是结点2i+1

#### 二叉树的遍历

* 前序遍历
* 中序遍历
* 后序遍历
* 层次遍历

 #### 查找二叉树

* 二叉排序树
* 左孩子小于根
* 右孩子大于根

##### 插入节点

1. 若该键值节点已存在，则不再插入
2. 若查找二叉树为空树，则以新节点为查找二叉树
3. 将要插入结点键值与插入后父节点键值比较，就能确定新节点是父节点的左子节点，还是右子节点

##### 删除节点

1. 若待删除结点是叶子节点，则直接删除
2. 若待删除节点只有一个子节点，则将这个子节点与待删除节点的父节点直接连接
3. 若待删除的节点p有两个子结点，则在其左子树上，用中序遍历寻找关键值最大的节点s，用节点s的值代替节点p的值，然后删除节点s，节点s必属于上述1，2情况之一

#### 最优二叉树

![1603356713323](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603356713323.png)

#### 线索二叉树

![1603357129893](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603357129893.png)

#### 平衡二叉树

![1603357348866](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603357348866.png)

### 图

#### 基本概念

完全图：在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图（complete graph）

在有向图中，若没对顶点之间都有两条有向边相互连接，则称该图为完全图

![1603365903229](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603365903229.png)

#### 图的存储

##### 邻接矩阵

用一个n阶方正R来存放图中各节点的关联信息，其矩阵元素Rij定义为：

![1603366002838](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603366002838.png)

##### 邻接表

首先把每个顶点的邻接顶点用链表表示出来，然后用一个以为数组来顺序存储上面每个链表的头指针

![1603367210053](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603367210053.png)

#### 图的遍历

##### 深度优先

​	类似于树的前序遍历

1. 首先访问出发顶点v
2. 一次从v出发搜索v的任意一个邻接点w
3. 若w未访问过，则从该点出发继续深度优先遍历

<img src="C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603367481274.png" with=300 height=150/>1 2 4 8 5 3 6 7

##### 广度优先

1. 首先访问出发顶点v
2. 然后访问与顶点v邻接的全部未访问顶点w，x，y...
3. 然后再依次访问w，x，y...邻接的未访问的顶点

<img src="C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603367481274.png" with=300 height=150/>1 2 3 4 5 6 7 8

#### 拓扑排序

我们吧用有向边表示活动之间开始的先后关系。这种有向图称为用顶点表示活动网络，简称AOV网络

<img src="C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1603369799673.png" with=300 height=100/>

上图的拓扑序列有：02143567, 01243657, 02143657, 01243567

#### 图的最小生成树

普利姆算法：确定一个点，去寻找

克鲁斯卡尔算法：直接找最短边