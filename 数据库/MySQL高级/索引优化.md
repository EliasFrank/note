**sql语句的执行顺序**

![1598016267423](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1598016267423.png)

![1598016312698](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1598016312698.png)

---

**七种JOIN**

---

**索引**  目的：提高查找效率，可以类比字典

MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构。

可以得到索引的本质：索引是数据结构（排好序的快速查找数据结构）

在数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据

这样就可以在某些数据结构上实现高级查找算法。这种数据结构就是索引。

一般来说，索引本身也很大，不可能全部储存在内存中，因此索引往往以索引文件的形式存储在磁盘上

**索引劣势**：

* 实际上索引也是一张表，该表保存了主键与索引中字段，并指向实体表的记录，所以索引列也是要占用空间的
* 虽然索引大大提高了查询速度，同时却会降低表的更新速度，如对表进行cud操作，因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段
* 索引只是提高效率的一个因素，如果你的MySQL有大数据量，就需要花时间建立最优秀的索引，或者优化查询

----

**索引分类**

* 单值索引：一个索引只包含单个列，一个表可以有多个单列索引
* 唯一索引：索引列的值必须唯一，但不允许有空值
* 复合索引：即一个索引包含多个列

---

**基本语法**

```
创建：
CREATE [UNIQUE] INDEX 索引名 ON 表名（列名）
ALTER 表名 ADD [[UNIQUE] INDEX [索引名] ON (列名)

删除：
DROP INDEX [索引名] ON 表名

查看：
SHOW INDEX FROM 表名
```

---

**建立索引的情况**

1. 那些情况需要创建索引
   * 主键自动建立唯一索引
   * 频繁作为查询条件的字段应该创建索引
   * 查询中与其他表关联的字段，外键关系建立索引
   * 频繁更新的字段不适合创建索引（因为每次更新不单单是更新了记录，还会更新索引）
   * where条件里用不到的字段不创建索引
   * 单键/组合索引的选择问题，（在高并发下倾向创建组合索引）
   * 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
   * 查询中统计或分组字段
2. 那些情况不要创建索引
   * 表记录太少
   * 经常增删改的表
   * 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。
   * 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果

---

**explain**

使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

作用：表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际引用、表之间的引用、每张表有多少行被优化器查询

执行计划包含的信息

* id 

  查询的序列号包含一组数字，表示查询中执行select子句或操作表的顺序

  * id相同：执行顺序由上至下
  * id不同，如果是子查询，id的序号会递增，id值越大，优先级越高，越先被执行
  * id相同不同，同时存在，先id，在顺序

* select_type

  simple、primary、subquery、derived、union、union result

  * 查询的类型、主要是用于区别
  * 普通查询、联合查询、子查询等的复杂查询
  * ![1598148497879](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1598148497879.png)

* table 

* type 

  * 显示查询使用了哪种类型：最好到最差依次是：

    system > const > eq_ref > ref > range > index > ALL 

  * system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计

  * const ： 表示通过索引依次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快将如主键置于where列表中，MySQL就能将该查询转换为一个常量

  * eq_ref：唯一性索引扫描，对于每个索引建，表中只有一条记录与之匹配。常见于主键或唯一索引扫描 

  * ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，他可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体

  * range：值检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在你的where语句中出现了between and、<、>、in等的子查询。这种范围扫描索引扫描比全表扫描要好，因为他只需要开始于索引的某一点，而结束于另一点，不用扫描全部案例

  * index：full index scan ， index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小（也就是说，虽然all与index都是读全表， 但index是从索引中读取的，而all是从硬盘中读的）

  * all：full table scan 将遍历全表以找到匹配的行

* possible_keys  ：显示可能应用在这张表的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用

* key ： 实际使用的索引。如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引仅出现在key列表中

* key_len ：表示索引使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，而并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的

* ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值

* rows ：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

* extra 

  * using filesort ：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 
  * using temporary：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表，常见于排序order by、分组查询group by
  * using index：表示相应的select操作中使用了覆盖索引（covering index）避免访问了表的数据行，效率不错。如果同时出现using where ，表明索引被用来执行索引键值的查找。如果没有同时出现，表明索引用来读取数据而非执行查找动作
  * using where 表明使用了where过滤
  * using join buffer：使用了连接缓存
  * impossible where ： where子句的值总是false，不能用来获取任何元组
  * select tables optimized away; 没有group by子句的情况下，基于索引优化min/max操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化
  * distinct

---

**索引失效的各种原因**

![1598276953751](C:\Users\hl2333\AppData\Roaming\Typora\typora-user-images\1598276953751.png)
